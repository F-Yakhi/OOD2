بخش اول تشخیص زیر مساله: 
الگوی state: 
شرط وجود الگوی state، رفتار وابسته به حالت در سیستم است. 
در این سیستم در کد اولیه کلاس TicketService شاهد شرط های طولانی if هستیم که هر کدام نشان دهنده یک state خاص در سیستم هستند و درواقع سیستم در هر حالت وارد یکی از این if ها میشود و رفتار متفاوتی از خود نشان میدهد. 
این موضوع از این جهت خطرناک است که بروز تغییرات و ایجاد state جدید در این سیستم بسیار مشکل است و نیاز به تغییرات زیاد در کلاس و متد handle دارد و نقض اصل ocp را به همراه دارد. 
برای رعایت این الگو به جای اینکه کلاس TicketService مسئول تصمیم گیری برای هر کدام از حالات سرویس باشد هر کلاس state مسئولیت رفتارهایش را بر عهده میگیرد. 
کلاس های مورد نیاز در این الگو:
۱-TicketContext: 
این کلاس state فعلی را نگه میدارد و متد handle را صدا میکند.(تصمیم گیری درباره نوع state ندارد) 
۲-TicketState:
اینترفیس مشترک برای تمام زیر کلاس های state. 
۳-NewState: 
زیرکلاسی که از اینترفیس TicketState ارثبری میکند و تیکت را میسازد بعد نوع کانال را چاپ میکند و به state بعدی یعنی assigned میرود. 
۴-AssignedState: 
بر اساس تایپ تیکت تصمیم میگیرد و به state بعدی میرود. 
۵-InProgressState: 
مشابه کلاس قبل عمل میکند. 
۶-ResolvedState: 
مشابه کلاس های دیگر. 
۷-ClosedState: 
پایان چرخه.

الگوی strategy: 
در این سیستم هر state میتواند رفتارش را با روش های متفاوت انجام دهد و در آن از شرط های متعدد if در متد هندل برای انتخاب کانال و انواع متفاوت تیکت استفاده کند. 
این موضوع سبب میشود اضافه کردن هر روش جدید تغییر در کل متد هندل ایجاد کند و باعث نقض اصل ocp شود. 
این شرط ها تصمیم گیری رفتاری سیستم هستند و با وضهیت سیستم ارتباطی ندارند و نباید در state ها بمانند. 
یاید طوری اصلاح کنیم که state ها فقط مسئول تعیین وضعیت و انتقال بین وضعیت ها باشند و روش ها از آنها جدا شود پس شرط ها حذف شده و به کلاس های مجزا میروند.
کلاس ها: 
WebReceiveStraregy, EmailReceiveStrategy: 
 کلاس های دریافت تیکت بسته به نوع کانال(و اینترفیس مربوطه). 
BugAssignStrategy, 
QuestionAssignStrategy: 
کلاس های تخصیص تیکت بسته به نوع تیکت(و اینترفیس مربوطه).
BugResponseStrategy, 
GenericResponseStrategy: 
کلاسهای پاسخدهی بسته به نوع تیکت (و اینترفیس مربوطه). 
کلاس generic برای تمام موارد غیر از bug است.

الگوی factory: 
در این سیستم، ساخت هر Ticket فقط ایجاد یک شیء ساده نیست، چون هنگام ساخته شدن باید مشخص شود درخواست از چه طریقی دریافت شده، به کدام بخش ارجاع داده شود، پاسخ آن چگونه باشد و وضعیت اولیه‌اش چه باشد.
از آن‌جایی که این موارد به نوع Ticket (مثل Bug یا Question) وابسته‌اند، اگر مستقیماً در کلاس‌هایی مثل Main انجام شوند، باعث وابستگی زیاد و سخت شدن توسعه‌ی سیستم می‌شوند.

به همین دلیل، منطق ساخت Ticket در یک کلاس جداگانه به نام TicketFactory قرار داده شده است. در این حالت، کلاس Main فقط نوع Ticket را مشخص می‌کند و جزئیات ساخت آن را نمی‌داند. این Factory بر اساس نوع Ticket تصمیم می‌گیرد از چه Strategyهایی استفاده شود و وضعیت اولیه‌ی Ticket چه باشد.

با این کار، استفاده‌ی مستقیم از new در کلاس‌های اصلی حذف شده، منطق ساخت اشیاء در یک نقطه متمرکز شده و در نتیجه اضافه کردن نوع جدید Ticket بدون تغییر در منطق اصلی سیستم امکان‌پذیر شده است. این موضوع باعث خواناتر شدن کد و رعایت بهتر اصل Open–Closed می‌شود.

بخش چهارم: 

SRP: 
قبل:
TicketService چند مسئولیت همزمان داشت مانند مدیریت stateها، تصمیم‌گیری بر اساس channel و type، و ارسال پاسخ. 
بعد:
هر State فقط مسئول رفتار خودش state است، Strategy فقط منطق پاسخ را مدیریت می‌کند و Factory فقط مسئول ساخت آبجکت‌ها است.
OCP
قبل:
اضافه شدن یک state یا نوع تیکت جدید باعث ایجاد تغییرات فراوان مانند تغییر متد handle و ifها می‌شد.
بعد:
با اضافه کردن کلاس جدید state یا strategy بدون تغییر کدهای قبلی میتوانیم کانال یا نوع تیکت جدید به سیستم اضافه کنیم. 
LSP
قبل:
رفتار سیستم به مقادیر و روش ها وابسته بود.
بعد:
همه Stateها و Strategyها قابل جایگزینی با interface مربوطه خود هستند بدون اینکه رفتار سیستم مختل شود در واقع ربطه is-a برقرار است.
ISP
قبل:
هیچ اینترفیسی مشخصی وجود نداشت و کلاس مجبور بود تمام کارها را یک‌جا انجام دهد.
بعد:
اینترفیس‌های کوچک و مشخص تعریف شدند و هر کلاس فقط متدهای مرتبط را پیاده‌سازی می‌کند.
DIP
قبل:
کد به if ها  وابسته بود و شی new میشد. 
بعد:
به وسیله پیاده سازی فکتوری این وابستگی رفت شده و کلاسهای سطح بالا به کلاسهای سطح پایین وابستگی ندارند. 
PLK 
قبل:
کلاس TicketService از جزئیات تمام stateها، نوع تیکت و کانال‌ها آگاه بود و با شرط‌های متعدد به آن‌ها وابسته بود.
بعد:
TicketContext فقط با State فعلی تعامل دارد و جزئیات رفتار داخل هر State قرار دارد در نتیجه مطابق PLK شده‌اند.
CRP 
قبل: زمانی که می‌خواستیم یکی از رفتارهای سیستم رو تغییر بدیم، مجبور می‌شدیم چند 
 بخش دیگه که مستقیم ربطی نداشتن را هم دستکاری کنیم و این باعث شلوغی و وابستگی زیاد می‌شد.
بعد: بعد از استفاده از الگوهای Strategy، State و Factory، هر رفتار توی کلاس‌های مربوط به خودش جدا شد. هر تغییری فقط در همان بخش انجام می‌شود و بقیه‌ی سیستم تحت تأثیر قرار نمی‌گیرد، بنابراین اصل CRP خیلی بهتر رعایت شده..



